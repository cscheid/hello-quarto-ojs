[
  {
    "href": "features/not-javascript.html#fancy-literals",
    "title": "Quarto + OJS",
    "section": "Fancy literals",
    "text": "There is also, for example, a more convenient way to create HTML elements:\n\nhtl.html`<button onlick=${clicked}>Click me!</button>`\n\n\n\n\n\n\nThis is much more succinct than the previous way we wrote it. Here, we’re using Observable’s hypertext literals, which allow you to build HTML elements using a familiar syntax that borrows from Javascript’s template literals."
  },
  {
    "href": "features/not-javascript.html#and-the-big-reveal",
    "title": "Quarto + OJS",
    "section": "… and the big reveal",
    "text": "That is all nice enough, but right now you’d be justified in thinking this is all a distinction without a difference. Consider this teaser, however:\n\n(new Date(now)).toJSON()\n\n\n\n\n\n\nHow is that string value updating itself automatically!? It’s time for you to learn the main feature of Observable’s runtime: reactive values.\n\nSource Code\n---\ntitle: \"Quarto + OJS\"\n---\n\nIn our simplest [Javascript example](javascript.qmd), we told you a\nsmall lie.  The code we execute is *not quite* Javascript.  Here's a\ndifferent way to write the same example:\n\n```{ojs}\n//| output: false\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n```\n\n```{ojs}\nbutton = {\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n```\n\nYou will notice right away that we're using a slightly different syntax here to define the `button` object. This is because what the Observable runtime provides is not *really* Javascript, but [a slight variant with some extensions](https://observablehq.com/@observablehq/observables-not-javascript). For now, it is sufficient for you to know that at the top level, `a = ...` is a *declaration*, not an assignment, and that declarations can be defined using Javascript blocks. The value of `a` is the return value of the block, exactly as if the block were used as the definition of a function.\n\n## Fancy literals\n\nThere is also, for example, a more convenient way to create HTML elements:\n\n```{ojs}\nhtl.html`<button onlick=${clicked}>Click me!</button>`\n```\n\nThis is much more succinct than the previous way we wrote it. Here, we're using Observable's [hypertext literals](https://observablehq.com/@observablehq/htl), which allow you to build HTML elements using a familiar syntax that borrows from Javascript's [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).\n\n## ... and the big reveal\n\nThat is all nice enough, but right now you'd be justified in thinking this is all a distinction without a difference. Consider this teaser, however:\n\n```{ojs}\n(new Date(now)).toJSON()\n```\n\nHow is that string value updating itself automatically!? It's time for you to learn the main feature of Observable's runtime: [reactive values](reactive-values.qmd)."
  },
  {
    "href": "features/javascript.html",
    "title": "Quarto + Javascript",
    "section": "",
    "text": "Quarto’s interactive features allow you to write and use Javascript in your documents. Let’s create the simplest possible example: a button which, when pressed, shows a popup alert. We will use Javascript’s alert function:\n\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n\n\n\n\n\n\nWe then need to create a button. We will use the createElement method to create a button, set its text value to “Click me!”, and set the onclick event handler to the function clicked we just defined:\n\nfunction createButton()\n{\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n\n\n\n\n\n\nWe can then simply call that function to create a button:\n\ncreateButton()\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Quarto + Javascript\"\n---\n\nQuarto's interactive features allow you to write and use Javascript in your documents.\nLet's create the simplest possible example: a button which, when pressed, shows a popup alert.\nWe will use Javascript's [alert](https://developer.mozilla.org/en-US/docs/Web/API/Window/alert) function:\n\n```{ojs}\n//| output: false\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n```\n\nWe then need to create a button. We will use the [`createElement` method](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to create a button, set its text value to \"Click me!\", and set the [`onclick` event handler](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick) to the function `clicked` we just defined:\n\n```{ojs}\n//| output: false\nfunction createButton()\n{\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n```\n\nWe can then simply call that function to create a button:\n\n```{ojs}\ncreateButton()\n```"
  },
  {
    "href": "features/sending-values-to-ojs.html#calling-ojs_define",
    "title": "ojs_define: Sending values to OJS",
    "section": "Calling ojs_define",
    "text": "Python\nHere’s a Python example that uses the subprocess command to get information about some files in the filesystem:\n\n\n\n\nimport subprocess\nout = subprocess.run([\"ls\", \"/usr/local\"], stdout=subprocess.PIPE).stdout.decode('ascii')\npy_file_list = out.split()\n\nWhat if we want to make that information available for the front-end, so that we could create (say) an interactive selection widget? In Quarto, you simply use the call to ojs_define:\n\nojs_define(py_file_list = py_file_list)\n\nThis makes sure there will be a variable py_file_list available for OJS modules.\n\n\nR\nIn R, the situation is very similar. The only difference is that R’s version of ojs_define is mildly smarter, and can sniff variable names from the declaration:\n\nr_file_list <- system2(c(\"ls\", \"/usr/local\"), stdout=TRUE)\nojs_define(r_file_list)"
  },
  {
    "href": "features/sending-values-to-ojs.html#using-the-values",
    "title": "ojs_define: Sending values to OJS",
    "section": "Using the values",
    "text": "We now can access those values as if they had been defined directly in OJS:\n\npy_file_list\nr_file_list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOf course, this means we can create a dropdown list as well:\n\nviewof fileName = Inputs.select(py_file_list, { label: \"Choose file\" })\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"`ojs_define`: Sending values to OJS\"\n---\n\nOften, Quarto pages will have a mix of R, Python and OJS chunks. At the\ntime the Quarto project renders, the R and Python code might query\ninto a database, do some data cleaning or some statistical\nmodeling. It's natural to want that data to be accessible.\n\nQuarto offers a unified mechanism in R and Python for doing so:\n`ojs_define`.\n\n## Calling `ojs_define`\n\n### Python\n\nHere's a Python example that uses the `subprocess`\ncommand to get information about some files in the filesystem:\n\n```{r}\n#| echo: false\n#| output: false\n\n# FIXME: This will be in a library somewhere.\n\nlibrary(reticulate)\n\nsetHook(\"reticulate.onPyInit\",\n  function() {\n    main <- import_main();\n    main$ojs_define <- function(...) {\n      quos <- rlang::enquos(...)\n      vars <- rlang::list2(...)\n      nm <- names(vars)\n      if (is.null(nm)) {\n        nm <- rep_len(\"\", length(vars))\n      }\n      contents <- jsonlite::toJSON(list(contents = I(mapply(\n        function(q, nm, val) {\n          # Infer name, if possible\n          if (nm == \"\") {\n            tryCatch({\n              nm <- rlang::as_name(q)\n            }, error = function(e) {\n              code <- paste(collapse = \"\\n\", deparse(rlang::f_rhs(q)))\n              stop(\"ojs_define() could not create a name for the argument: \", code)\n            })\n          }\n          list(name=nm, value=val)\n        }, quos, nm, vars, SIMPLIFY = FALSE, USE.NAMES=FALSE))),\n        dataframe = \"columns\", null = \"null\", na = \"null\", auto_unbox = TRUE);\n      invisible(knitr:::knit_meta_add(list(\n        structure(\n          class=\"ojs-define\",\n          c(\"<script type=\\\"ojs-define\\\">\",\n            contents,\n            \"</script>\")))));\n      NULL\n    };\n});\n```\n\n```{python}\nimport subprocess\nout = subprocess.run([\"ls\", \"/usr/local\"], stdout=subprocess.PIPE).stdout.decode('ascii')\npy_file_list = out.split()\n```\n\nWhat if we want to make that information available for the front-end,\nso that we could create (say) an interactive selection widget? In\nQuarto, you simply use the call to `ojs_define`:\n\n```{python}\nojs_define(py_file_list = py_file_list)\n```\n\nThis makes sure there will be a variable `py_file_list` available for OJS modules.\n\n### R\n\nIn R, the situation is very similar. The only difference is that R's\nversion of `ojs_define` is mildly smarter, and can sniff variable names from the declaration:\n\n```{r}\nr_file_list <- system2(c(\"ls\", \"/usr/local\"), stdout=TRUE)\nojs_define(r_file_list) \n```\n\n## Using the values\n\nWe now can access those values as if they had been defined directly in OJS:\n\n```{ojs}\npy_file_list\nr_file_list\n```\n\nOf course, this means we can create a dropdown list as well:\n\n```{ojs}\nviewof fileName = Inputs.select(py_file_list, { label: \"Choose file\" })\n```"
  },
  {
    "href": "features/dot.html",
    "title": "Graphviz support",
    "section": "",
    "text": "You can use Observable’s dot template literal:\n\ndot`digraph { a -> b; }`\n\n\n\n\n\n\nIt’s also possible to use a slightly terser syntax with the dot chunk language:\n\ndigraph { a -> b; }\n\n\n\n\n\n\nTesting yaml-style metadata inside dot chunks:\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Graphviz support\"\n---\n\nYou can use Observable's `dot` template literal:\n\n```{ojs}\ndot`digraph { a -> b; }`\n```\n\nIt's also possible to use a slightly terser syntax with the `dot` chunk language:\n\n```{dot}\ndigraph { a -> b; }\n```\n\nTesting yaml-style metadata inside `dot` chunks:\n\n```{dot}\n//| echo: false\ndigraph { \n  no -> source; \n  source -> here; \n}\n```"
  },
  {
    "href": "features/file-attachments.html",
    "title": "Files and File Attachments",
    "section": "",
    "text": "OJS provides you with a ton of flexibility and options for interactivity on the browser side. But what if you want to interact with files in the file system? This is very common when you have some R or Python code that generates some data to be visualized. Quarto OJS provides FileAttachment objects, or simply “file attachments”.\nFile attachments work similarly to how they do in Observable. You include them as a resource in your quarto document or project, and then access them with FileAttachment. Here we’re using Allison Horst’s excellent palmer penguins dataset (source):\n\n# This R code is run by Quarto, just like it would in (say) Rmarkdown.\nlibrary(palmerpenguins)\nwrite.csv(penguins, \"penguins.csv\")\n\nWe now can reference this file directly in file attachments.\n\ndata = FileAttachment(\"penguins.csv\").csv()\navg = {\n  const vs = data.map(s => s.bill_length_mm).filter(s => s !== \"NA\").map(Number);\n  let n = 0;\n  vs.forEach(v => n += v);\n  return n / vs.length;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe average bill length of penguins in the dataset is mm.\n\nWhich files are included?\nWhen you render a Quarto document, Quarto inspects OJS chunks and tries to figure out which files the document intends to use as attachment to automatically include them in the build (typically in the _site directory). It does so by inspecting OJS source code, looking for FileAttachment(...) calls with string literals as parameters.\nThis works well in simple cases, but more complex code might have arbitrary logic to decide on which filename to load. In that case, it will be necessary to explicitly add those files as resources in the YAML frontmatter (either for the project itself or some of its pages). Here’s an example:\ntitle: \"This is the title of some page with attachments\"\nresources:\n  - penguins.csv\n  - data/*.csv\n(FIXME: Apparently file attachments only work with string literals anyway!)\n\n\nHow are paths resolved?\nQuarto is careful to convert all local URL paths to “root-relative” paths, so that the entire Quarto project you build works, regardless of how deep in a web server path hierarchy you serve its content from. In other words, if your markdown includes an image URL /imgs/asset-1.jpg, Quarto will convert that URL to a relative one. In Quarto OJS, FileAttachments work the same way. For example, here we check that penguins.csv and /features/penguins.csv indeed seem to be the same file, by looking at random rows of the file and verifying that they have the same bill lengths:\n\ndata2 = FileAttachment(\"/features/penguins.csv\").csv()\n{\n    let randomRow = (now & 65535) % data.length;\n    return data2[randomRow].bill_length_mm === data[randomRow].bill_length_mm;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Files and File Attachments\"\n---\n\nOJS provides you with a ton of flexibility and options for\ninteractivity on the browser side.  But what if you want to interact\nwith files in the file system? This is very common when you have some\nR or Python code that generates some data to be visualized.\nQuarto OJS provides `FileAttachment` objects, or simply \"file attachments\".\n\nFile attachments work similarly to how they do in Observable. You include them as\na resource in your quarto document or project, and then access them\nwith `FileAttachment`. Here we're using Allison Horst's excellent\n[palmer penguins dataset](penguins.csv)\n([source](https://allisonhorst.github.io/palmerpenguins/)):\n\n```{r}\n# This R code is run by Quarto, just like it would in (say) Rmarkdown.\nlibrary(palmerpenguins)\nwrite.csv(penguins, \"penguins.csv\")\n```\n\nWe now can reference this file directly in [file attachments](https://observablehq.com/@observablehq/file-attachments).\n\n```{ojs}\n//| output: false\ndata = FileAttachment(\"penguins.csv\").csv()\navg = {\n  const vs = data.map(s => s.bill_length_mm).filter(s => s !== \"NA\").map(Number);\n  let n = 0;\n  vs.forEach(v => n += v);\n  return n / vs.length;\n}\n```\n\nThe average bill length of penguins in the dataset is ${fmt(avg)}mm.\n\n### Which files are included?\n\nWhen you render a Quarto document, Quarto inspects OJS chunks and\ntries to figure out which files the document intends to use as\nattachment to automatically include them in the build (typically in\nthe `_site` directory). It does so by inspecting OJS source code,\nlooking for `FileAttachment(...)` calls with string literals as parameters. \n\nThis works well in simple cases, but more complex code might have\narbitrary logic to decide on which filename to load. In that case, it\nwill be necessary to explicitly add those files as resources in the\nYAML frontmatter (either for the project itself or some of its\npages). Here's an example:\n\n```\ntitle: \"This is the title of some page with attachments\"\nresources:\n  - penguins.csv\n  - data/*.csv\n```\n\n(FIXME: Apparently [file attachments only work with string literals anyway!](https://observablehq.com/@observablehq/file-attachments))\n\n### How are paths resolved?\n\nQuarto is careful to convert all local URL paths to \"root-relative\"\npaths, so that the entire Quarto project you build works, regardless\nof how deep in a web server path hierarchy you serve its content from.\nIn other words, if your markdown includes an image URL\n`/imgs/asset-1.jpg`, Quarto will convert that URL to a relative\none. In Quarto OJS, FileAttachments work the same way. For example,\nhere we check that `penguins.csv` and `/features/penguins.csv` indeed\nseem to be the same file, by looking at random rows of the file and\nverifying that they have the same bill lengths:\n\n```{ojs}\ndata2 = FileAttachment(\"/features/penguins.csv\").csv()\n{\n    let randomRow = (now & 65535) % data.length;\n    return data2[randomRow].bill_length_mm === data[randomRow].bill_length_mm;\n}\n```\n\n\n```{ojs}\n//| echo: false\n//| output: false\nfunction fmt(n)\n{\n   let s = String(~~n);\n   return s.substr(s.length - 2);\n}\n```\n\n\n\n\n{\"contents\":[\n  {\"methodName\":\"interpret\",\"inline\":\"true\",\"source\":\"htl.html`<span>${fmt(avg)}</span>`\", \"cellName\":\"ojs-element-id-1\"}\n]}"
  },
  {
    "href": "features/observable-modules.html#reusable-code-ojs-vs-htmlwidgets",
    "title": "OJS Modules",
    "section": "Reusable code: OJS vs htmlwidgets",
    "text": "One of the unique features of Observable’s module system is the ease with which notebooks can be reused and remixed.\n\nSource Code\n---\ntitle: \"OJS Modules\"\n---\n\nIf you want to use the many existing observable modules\nthat are present in the ecosystem, you can do so in the same way\nas you would in ObservableHQ. This way, Quarto users can contribute\nto the ObservableHQ ecosystem and vice-versa.\n\nThis example comes from Sean Lopp's excellent [\"Observable for R\nUsers\" notebook](https://observablehq.com/@slopp/observable-for-r-users).\n\nYou can use their `require` syntax:\n\n```{ojs}\n//| output: false\nvg = require('vega-lite');\npenguins = FileAttachment(\"penguins.csv\").csv();\n```\n\n```{ojs}\nvl\n  .markPoint()                           // the first two lines are akin to ggplot(data = penguins) + geom_point\n  .data(penguins)\n  .encode(                               // encode is like aes\n    vl.x().fieldQ('body_mass_g')         // aes(x = body_mass_g)\n          .scale({domain: [2000, 6500]}) // modify scale attributes, similar to scale_x_axis\n          .axis({title: \"Mass (g)\"}),\n    vl.y().fieldQ('bill_length_mm')     \n          .scale({domain: [30, 60]}),\n    vl.color().fieldN('species'),\n    vl.tooltip(['species', 'sex', 'year', 'island'])  // tooltips for free!\n).render()\n```\n\nYou can also import directly from a live ObservableHQ notebook. Let's\ntry a simple example using sliders:\n\n```{ojs}\n//| output: false\nimport {slider} from \"@jashkenas/inputs\"\n```\n\nHere, we're also using [Quarto's custom layouts](https://quarto.org/docs/authoring/figures-and-layout.html#complex-layouts),\nwhich help when building dashboards.\n\n```{ojs}\n//| layout: \"[[30, -5, 30, -5, 30], [100]]\"\nviewof hue = slider({min: 0, max: 360, title: \"Hue\"})\nviewof chroma = slider({min: 0, max: 100, title: \"Chroma\"})\nviewof luminance = slider({min: 0, max: 100, title: \"Luminance\"})\ncolor = {\n  const fill = d3.hcl(hue, chroma, luminance);\n  const r = htl.svg`<rect width=\"${width}\" height=\"30\" fill=\"${fill}\"/>`;\n  const s = DOM.svg(width, 30);\n  s.appendChild(r);\n  return s;\n}\n```\n\n## Reusable code: OJS vs htmlwidgets\n\nOne of the unique features of Observable's module system is the ease\nwith which notebooks can be reused and remixed."
  },
  {
    "href": "features/reactive-values.html#enter-reactive-values",
    "title": "Reactive Values",
    "section": "Enter reactive values",
    "text": "OJS, on the other hand, lets you define “reactive” values: special values that can change, and notify downstream code about the change. So, we can write this instead:\n\n// \"now\" is a predefined reactive value that returns the current\n// value of Date.now()\nreactiveTime = {\n  const hours = (now / (3600 * 1000)) % 12;\n  const minutes = (now / (60 * 1000)) % 60;\n  const seconds = (now / 1000) % 60;\n  \n  return { hours, minutes, seconds };\n}\n\n\n\n\n\n\nNow the values automatically update themselves. In OJS, you can write code that uses these as if they were regular Javascript values. OJS notices you’re using reactive values, and turns your definition into a reactive value as well:\n\ntimeString = htl.html`<tt>${fmt(reactiveTime.hours)}:${fmt(reactiveTime.minutes)}:${fmt(reactiveTime.seconds)}</tt>`\n\n\n\n\n\n\nBut we wanted an analog clock. So let’s make an analog clock, using SVG.\n\nclock = {\n   const { hours, minutes, seconds } = reactiveTime;\n   const result = svg`<svg width=200 height=200></svg>`;\n   const hourAngle = toClockAngle(hours / 12);\n   const minuteAngle = toClockAngle(minutes / 60);\n   const secondAngle = toClockAngle(seconds / 60);\n   const main = svg`<g transform=\"translate(100, 100) scale(1, -1)\"></g>`;\n   \n   result.appendChild(main);\n   main.appendChild(svg`<circle r=95 fill=\"#eee\"></circle>`);\n   main.appendChild(clockHand(secondAngle, \"red\", 1));\n   main.appendChild(clockHand(minuteAngle, \"black\", 1));\n   main.appendChild(clockHand(hourAngle, \"black\", 3));\n   return result;\n}\n\n\n\n\n\nFigure 1: An SVG clock built with reactive values.1\n\n\n\nOJS makes sure your SVG definition is also reactive, since it also uses reactive values."
  },
  {
    "href": "features/reactive-values.html#extras",
    "title": "Reactive Values",
    "section": "Extras",
    "text": "function fmt(n)\n{\n   const s = (\"00\" + String(~~n));\n   return s.substr(s.length - 2);\n}\nfunction toClockAngle(v)\n{\n  // some math is needed here because unlike polar coordinates, \n  // clock hands run clockwise and start at the \"north pole\"\n  return -(-Math.PI / 2 + Math.PI * 2 * v) * (180 / Math.PI);\n}\nfunction clockHand(angle, color, width)\n{\n  return svg`<line transform=\"rotate(${angle})\" x1=0 y1=0 x2=90 y2=0 stroke=${color} stroke-width=${width}></line>`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Reactive Values\"\n---\n\nThe fundamental difference between \"plain Javascript\" and Observable's\nversion of Javascript (here, \"OJS\") is its native support for\n_reactivity_.\n\nImagine you wanted to create a simple visual time display shaped like\nan analog clock (or, looking ahead, imagine a JS dashboard that\nperiodically updates itself). Whatever you end up showing ultimately will\ndepend on the current time. So you start writing functions which compute\nthe present time:\n\n```{ojs}\n//| output: false\ncurrentTime = function() {\n  return Date.now();\n}\ncurrentHours = function() {\n  return (Date.now() / (3600 * 1000)) % 12;\n}\ncurrentMinutes = function() {\n  return (Date.now() / (60 * 1000)) % 60;\n}\ncurrentSeconds = function() {\n  return (Date.now() / 1000) % 60;\n}\n```\n\nBut `Date.now()` is always changing, and so your plain Javascript code needs\ninfrastructure to update the display constantly, otherwise that value\nis only computed once per call:\n\n```{ojs}\nstaticTime = { \n  return { hours: currentHours(), minutes: currentMinutes(), seconds: currentSeconds() };\n}\nhtl.html`<tt>${fmt(currentHours())}:${fmt(currentMinutes())}:${fmt(currentSeconds())}</tt>`\n```\n\n\"This is fine,\" you say. After all, we have Javascript:\n\n```{ojs}\nttEl = {\n  return document.createElement(\"tt\");\n}\n```\n```{ojs}\n//| output: false\nfunction updateEl() {\n  ttEl.innerText = `${fmt(currentHours())}:${fmt(currentMinutes())}:${fmt(currentSeconds())}`;\n  window.requestAnimationFrame(updateEl);\n}\nupdateEl()\n```\n\nBut what if your data only updates once a minute? What if you _don't\nknow_ how often your data updates?  Eventually code like this becomes\na delicate dance of signals and event handlers.  Things can get\nquickly out of hand.\n\n## Enter reactive values\n\nOJS, on the other hand, lets you define \"reactive\" values: special values that can\nchange, _and notify downstream code about the change_. So, we can write this instead:\n\n```{ojs}\n// \"now\" is a predefined reactive value that returns the current\n// value of Date.now()\nreactiveTime = {\n  const hours = (now / (3600 * 1000)) % 12;\n  const minutes = (now / (60 * 1000)) % 60;\n  const seconds = (now / 1000) % 60;\n  \n  return { hours, minutes, seconds };\n}\n```\n\nNow the values automatically update themselves. In OJS, you can\nwrite code that uses these as if they were regular Javascript\nvalues. OJS notices you're using reactive values, and turns\nyour definition into a reactive value as well:\n\n```{ojs}\ntimeString = htl.html`<tt>${fmt(reactiveTime.hours)}:${fmt(reactiveTime.minutes)}:${fmt(reactiveTime.seconds)}</tt>`\n```\n\nBut we wanted an analog clock. So let's make an analog clock, using\nSVG.\n\n```{ojs}\n//| label: fig-1\n//| fig.cap: An SVG clock built with reactive values.[^1]\nclock = {\n   const { hours, minutes, seconds } = reactiveTime;\n   const result = svg`<svg width=200 height=200></svg>`;\n   const hourAngle = toClockAngle(hours / 12);\n   const minuteAngle = toClockAngle(minutes / 60);\n   const secondAngle = toClockAngle(seconds / 60);\n   const main = svg`<g transform=\"translate(100, 100) scale(1, -1)\"></g>`;\n   \n   result.appendChild(main);\n   main.appendChild(svg`<circle r=95 fill=\"#eee\"></circle>`);\n   main.appendChild(clockHand(secondAngle, \"red\", 1));\n   main.appendChild(clockHand(minuteAngle, \"black\", 1));\n   main.appendChild(clockHand(hourAngle, \"black\", 3));\n   return result;\n}\n```\n\nOJS makes sure your SVG definition is also reactive, since it\nalso uses reactive values.\n\n## Extras\n\n```{ojs}\n//| output: false\nfunction fmt(n)\n{\n   const s = (\"00\" + String(~~n));\n   return s.substr(s.length - 2);\n}\nfunction toClockAngle(v)\n{\n  // some math is needed here because unlike polar coordinates, \n  // clock hands run clockwise and start at the \"north pole\"\n  return -(-Math.PI / 2 + Math.PI * 2 * v) * (180 / Math.PI);\n}\nfunction clockHand(angle, color, width)\n{\n  return svg`<line transform=\"rotate(${angle})\" x1=0 y1=0 x2=90 y2=0 stroke=${color} stroke-width=${width}></line>`\n}\n```\n\n[^1]: Note that `now` doesn't take timezones into account, so you're likely to see your clock a few hours off."
  },
  {
    "href": "tests/svg-test-1.html",
    "title": "SVG test 1",
    "section": "",
    "text": "mySvg = {\n  debugger;\n  return svg``;\n}\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"SVG test 1\"\n---\n\n```{ojs}\nmySvg = {\n  debugger;\n  return svg``;\n}\n```"
  },
  {
    "href": "tests/test-ojs-viewof-1.html",
    "title": "Testing OHQ views",
    "section": "",
    "text": "viewof x = html`<input type=range min=0 max=1 step=any>`\n\n\n\n\n\n\nWhat happens here?\n\n\nviewof x1 = html`<input type=range min=0 max=1 step=any>`\nviewof x2 = html`<input type=range min=0 max=1 step=any>`\n~~((x1 + x2) * 100)\n\n\n\n\n\n\n(a) the first view\n\n\n\n\n\n\n\n\n\n(b) the second view\n\n\n\n\n\n\n\n\n\n(c) the third element\n\n\n\nFigure 1: Many viewofs\n\n\n\nSource Code\n---\ntitle: \"Testing OHQ views\"\n---\n\n```{ojs}\nviewof x = html`<input type=range min=0 max=1 step=any>`\n```\n\nWhat happens here?\n\n```{ojs}\n//| label: fig-2\n//| fig.cap: \"Many viewofs\"\n//| fig.subcap:\n//|   - \"the first view\"\n//|   - \"the second view\"\n//|   - \"the third element\"\nviewof x1 = html`<input type=range min=0 max=1 step=any>`\nviewof x2 = html`<input type=range min=0 max=1 step=any>`\n~~((x1 + x2) * 100)\n```"
  },
  {
    "href": "tests/test-ojs-grammar-node-types.html",
    "title": "Inspecting the OJS grammar",
    "section": "",
    "text": "1;\nvar1 = 3;\nviewof var2 = html`<input type=range min=0 max=1 step=any>`;\n({ foo: \"bar\" });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Inspecting the OJS grammar\"\n---\n\n```{ojs}\n1;\nvar1 = 3;\nviewof var2 = html`<input type=range min=0 max=1 step=any>`;\n({ foo: \"bar\" });\n```"
  },
  {
    "href": "tests/index.html#svg",
    "title": "Quarto Observable Test Index",
    "section": "SVG",
    "text": "svg-test-1."
  },
  {
    "href": "tests/index.html#ojs-display-tests",
    "title": "Quarto Observable Test Index",
    "section": "OJS display tests",
    "text": "OJS grammar node types\nOJS object inspector"
  },
  {
    "href": "tests/index.html#views",
    "title": "Quarto Observable Test Index",
    "section": "Views",
    "text": "test 1\n\n\nSource Code\n---\ntitle: \"Quarto Observable Test Index\"\n---\n\n## SVG\n\n* [svg-test-1](svg-test-1.qmd).\n\n## OJS display tests\n\n* [OJS grammar node types](test-ojs-grammar-node-types.qmd)\n* [OJS object inspector](test-ojs-object-inspector.qmd)\n\n## Views\n\n* [test 1](test-ojs-viewof-1.qmd)"
  },
  {
    "href": "tests/test-ojs-object-inspector.html",
    "title": "Test OJS Object Inspector",
    "section": "",
    "text": "v = ({\n  a: 1,\n  b: \"foo\",\n  c: null,\n  d: true,\n  e: undefined,\n  f: [1, 2, 3],\n  g: {\n    some: \"more\"\n  },\n  h: function(x) { return x + x; },\n  i: (y) => y * y\n})\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Test OJS Object Inspector\"\n---\n\n```{ojs}\nv = ({\n  a: 1,\n  b: \"foo\",\n  c: null,\n  d: true,\n  e: undefined,\n  f: [1, 2, 3],\n  g: {\n    some: \"more\"\n  },\n  h: function(x) { return x + x; },\n  i: (y) => y * y\n})\n```"
  },
  {
    "href": "index.html#getting-started-with-quarto-ojs",
    "title": "Quarto OJS",
    "section": "Getting started with Quarto OJS",
    "text": "Using Javascript\nUsing OJS\nReactive values\nCommunicating between R, Python, and OJS\n\nSending values\nUsing files\n\n\n\nSource Code\n---\ntitle: \"Quarto OJS\"\n---\n\nQuarto provides a number of format outputs, one of which is HTML. The\nHTML format uniquely supports **interactivity**: web browsers can show\nanimations, respond to user input, and run user-defined code.\nQuarto leverages [ObservableHQ](https://observablehq.com)'s runtime \nto support this kind of interactivity.\nAt a glance, this enables document authors to write code in a variant\nof Javascript. We can use it to easily embed interactive visualizations in\nQuarto documents:\n\n```{ojs}\n//| echo: false\n//| output: false\ngraphJson = FileAttachment(\"./data/karate-club.json\").json()\ngraph = {\n  const nodeSet = new Set();\n  const nodes = [];\n  graphJson.edges.forEach(edge => {\n    if (!nodeSet.has(edge.source)) {\n      nodeSet.add(edge.source);\n      nodes.push({id: edge.source});\n    }\n    if (!nodeSet.has(edge.target)) {\n      nodeSet.add(edge.target);\n      nodes.push({id: edge.target});\n    }\n  });\n  return {\n    nodes,\n    links: graphJson.edges\n  };\n}\nmyHeight = 400\nimport { chart } with { graph as data, myHeight as height } from \"@d3/force-directed-graph\";\n```\n\n```{ojs}\n//| echo: false\n//| label: fig-karate-club\n//| fig.cap: <a href=\"https://en.wikipedia.org/wiki/Zachary%27s_karate_club\">Zachary's Karate club network</a>, visualized with d3's force-directed layout\nchart\n```\nQuarto-OJS is built to make it easy for document authors to create a\nrange of documents, from interactive expository pieces to dashboards.\n\nYour documents can use Python or R for data processing, and then use a\nnumber of Javascript libraries (such as d3 or vega-lite) to present\nthe final output. You can write your own custom Javascript, or you can\ndirectly import from existing reactive notebook, either in your Quarto\nproject or from ObservableHQ. If you're using R specifically, you can\nuse Quarto to build and run Shiny servers, and Shiny interop is a\nbreeze: Shiny reactives work directly as inputs to OJS cells (and OJS\nviews work as Shiny inputs).\n\n## Getting started with Quarto OJS\n\n* [Using Javascript](features/javascript.qmd)\n* [Using OJS](features/not-javascript.qmd)\n* [Reactive values](features/reactive-values.qmd)\n* Communicating between R, Python, and OJS\n  * [Sending values](features/sending-values-to-ojs.qmd)\n  * [Using files](features/file-attachments.qmd)"
  },
  {
    "href": "module-tests/default-module-import.html",
    "title": "Default Module Import test",
    "section": "",
    "text": "Let’s observe ojs imports.\n\nimport { slider } from \"@jashkenas/inputs\"\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Default Module Import test\"\n---\n\nLet's observe ojs imports.\n\n```{ojs}\nimport { slider } from \"@jashkenas/inputs\"\n```"
  },
  {
    "href": "module-tests/module-import-2.html",
    "title": "ES6 Recursive Imports",
    "section": "",
    "text": "We also support ES6 recursive imports, and Quarto traverses the ES6 modules recursively to include them as resources in your project.\n\n// test-2.js itself imports a bar.js ES6 module.\nimport { v1, v2 } from \"./test-2.js\";\n\n\n\n\n\n\n\nv1()\nv2()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"ES6 Recursive Imports\"\n---\n\nWe also support ES6 recursive imports, and Quarto traverses the ES6 modules\nrecursively to include them as resources in your project.\n\n```{ojs}\n// test-2.js itself imports a bar.js ES6 module.\nimport { v1, v2 } from \"./test-2.js\";\n```\n\n```{ojs}\nv1()\nv2()\n```"
  },
  {
    "href": "module-tests/es6-module-import.html",
    "title": "ES6 Module Imports",
    "section": "",
    "text": "In addition to regular imports from observablehq notebooks, Quarto OJS also supports ES6 module imports from local files. In this basic case, we have a very simple test file:\n\nimport { test } from \"./test.js\";\ntest()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuarto notices the ./test.js being imported and automatically includes it as a resource to be added to the project build.\n\nSource Code\n---\ntitle: \"ES6 Module Imports\"\n---\n\nIn addition to regular imports from observablehq notebooks, Quarto OJS also\nsupports ES6 module imports from local files. In this basic case, we\nhave a [very simple test file](test.js):\n\n```{ojs}\nimport { test } from \"./test.js\";\ntest()\n```\n\nQuarto notices the `./test.js` being imported and automatically\nincludes it as a resource to be added to the project build."
  },
  {
    "href": "module-tests/ojs-module.html",
    "title": "OJS module",
    "section": "",
    "text": "An import from a simple module:\n\nimport { nowInSecs } from './test.ojs'\nnowInSecs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn import from a slightly more complicated module:\n\nimport { out } from './test-2.ojs'\nout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, we can import modules from other Quarto-OJS notebooks. In this case, we simply import the SVG clock we created in the reactive values intro:\n\nimport { clock } from '../features/reactive-values.qmd';\nclock\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"OJS module\"\n---\n\nAn import from a simple module:\n\n```{ojs}\nimport { nowInSecs } from './test.ojs'\nnowInSecs\n```\n\nAn import from a slightly more complicated module:\n\n```{ojs}\nimport { out } from './test-2.ojs'\nout\n```\n\nFinally, we can import modules from other Quarto-OJS notebooks. In\nthis case, we simply import the SVG clock we created [in the reactive values intro](../features/reactive-values.qmd):\n\n```{ojs}\nimport { clock } from '../features/reactive-values.qmd';\nclock\n```"
  },
  {
    "href": "module-tests/module-import.html",
    "title": "Module Import test",
    "section": "",
    "text": "We’ll have to override the import statements here to do something special.\n\nimport { test } from \"./test.js\";\n\n\n\n\n\n\n\ntest()\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Module Import test\"\n---\n\nWe'll have to override the import statements here to do something special.\n\n```{ojs}\nimport { test } from \"./test.js\";\n```\n\n```{ojs}\ntest()\n```"
  }
]
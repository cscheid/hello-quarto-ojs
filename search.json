[
  {
    "href": "features/not-javascript.html#fancy-literals",
    "title": "Quarto + OJS",
    "section": "Fancy literals",
    "text": "There is also, for example, a more convenient way to create HTML elements:\n\nhtl.html`<button onlick=${clicked}>Click me!</button>`\n\n\n\n\n\n\nThis is much more succinct than the previous way we wrote it. Here, we’re using Observable’s hypertext literals, which allow you to build HTML elements using a familiar syntax that borrows from Javascript’s template literals."
  },
  {
    "href": "features/not-javascript.html#and-the-big-reveal",
    "title": "Quarto + OJS",
    "section": "… and the big reveal",
    "text": "That is all nice enough, but right now you’d be justified in thinking this is all a distinction without a difference. Consider this teaser, however:\n\n(new Date(now)).toJSON()\n\n\n\n\n\n\nHow is that string value updating itself automatically!? It’s time for you to learn the main feature of Observable’s runtime: reactive values.\n\nSource Code\n---\ntitle: \"Quarto + OJS\"\n---\n\nIn our simplest [Javascript example](javascript.qmd), we told you a\nsmall lie.  The code we execute is *not quite* Javascript.  Here's a\ndifferent way to write the same example:\n\n```{ojs}\n//| output: false\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n```\n\n```{ojs}\nbutton = {\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n```\n\nYou will notice right away that we're using a slightly different syntax here to define the `button` object. This is because what the Observable runtime provides is not *really* Javascript, but [a slight variant with some extensions](https://observablehq.com/@observablehq/observables-not-javascript). For now, it is sufficient for you to know that at the top level, `a = ...` is a *declaration*, not an assignment, and that declarations can be defined using Javascript blocks. The value of `a` is the return value of the block, exactly as if the block were used as the definition of a function.\n\n## Fancy literals\n\nThere is also, for example, a more convenient way to create HTML elements:\n\n```{ojs}\nhtl.html`<button onlick=${clicked}>Click me!</button>`\n```\n\nThis is much more succinct than the previous way we wrote it. Here, we're using Observable's [hypertext literals](https://observablehq.com/@observablehq/htl), which allow you to build HTML elements using a familiar syntax that borrows from Javascript's [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).\n\n## ... and the big reveal\n\nThat is all nice enough, but right now you'd be justified in thinking this is all a distinction without a difference. Consider this teaser, however:\n\n```{ojs}\n(new Date(now)).toJSON()\n```\n\nHow is that string value updating itself automatically!? It's time for you to learn the main feature of Observable's runtime: [reactive values](reactive-values.qmd)."
  },
  {
    "href": "features/javascript.html",
    "title": "Quarto + Javascript",
    "section": "",
    "text": "Quarto’s interactive features allow you to write and use Javascript in your documents. Let’s create the simplest possible example: a button which, when pressed, shows a popup alert. We will use Javascript’s alert function:\n\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n\n\n\n\n\n\nWe then need to create a button. We will use the createElement method to create a button, set its text value to “Click me!”, and set the onclick event handler to the function clicked we just defined:\n\nfunction createButton()\n{\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n\n\n\n\n\n\nWe can then simply call that function to create a button:\n\ncreateButton()\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Quarto + Javascript\"\n---\n\nQuarto's interactive features allow you to write and use Javascript in your documents.\nLet's create the simplest possible example: a button which, when pressed, shows a popup alert.\nWe will use Javascript's [alert](https://developer.mozilla.org/en-US/docs/Web/API/Window/alert) function:\n\n```{ojs}\n//| output: false\nfunction clicked()\n{\n    alert(\"You clicked the button!\")\n}\n```\n\nWe then need to create a button. We will use the [`createElement` method](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to create a button, set its text value to \"Click me!\", and set the [`onclick` event handler](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick) to the function `clicked` we just defined:\n\n```{ojs}\n//| output: false\nfunction createButton()\n{\n  let result = document.createElement(\"button\");\n  result.innerText = \"Click me!\";\n  result.onclick = clicked;\n  return result;\n}\n```\n\nWe can then simply call that function to create a button:\n\n```{ojs}\ncreateButton()\n```"
  },
  {
    "href": "features/file-attachments.html",
    "title": "Files and File Attachments",
    "section": "",
    "text": "OJS provides you with a ton of flexibility and options for interactivity on the browser side. But what if you want to interact with files in the file system? This is very common when you have some R or Python code that generates some data to be visualized. Quarto OJS provides FileAttachment objects, or simply “file attachments”.\nFile attachments work similarly to how they do in Observable. You include them as a resource in your quarto document or project, and then access them with FileAttachment. Here we’re using Allison Horst’s excellent palmer penguins dataset (source):\n\n# This R code is run by Quarto, just like it would in (say) Rmarkdown.\nlibrary(palmerpenguins)\nwrite.csv(penguins, \"penguins.csv\")\n\nWe now can reference this file directly in a file attachment:\n\ndata = FileAttachment(\"penguins.csv\").csv()\n\n\n\n\n\n\nQuarto tries to figure out which files you want to use as attachments by inspecting OJS source code for FileAttachment(...) literals. If you have arbitrary logic to decide on which filename to load, you will need to explicitly add those files as resources in your project’s YAML frontmatter (or in some of its pages).\n\navg = {\n  const vs = data.map(s => s.bill_length_mm).filter(s => s !== \"NA\").map(Number);\n  let n = 0;\n  vs.forEach(v => n += v);\n  return n / vs.length;\n}\n\n\n\n\n\n\nThe average bill length of penguins in the dataset is mm.\n\nRoot-relative FileAttachments\nQuarto is careful to convert all local URL paths to “root-relative” paths, so that the entire Quarto project you build works, regardless of how deep in a web server path hierarchy you serve its content from. In other words, if your markdown includes an image URL /imgs/asset-1.jpg, Quarto will convert that URL to a relative one. In Quarto OJS, FileAttachments work the same way. For example, here we check that penguins.csv and /features/penguins.csv indeed seem to be the same file:\n\ndata2 = FileAttachment(\"/features/penguins.csv\").csv()\n{\n    let randomRow = (now & 65535) % data.length;\n    return data2[randomRow].bill_length_mm === data[randomRow].bill_length_mm;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtras\n\nfunction fmt(n)\n{\n   let s = String(~~n);\n   return s.substr(s.length - 2);\n}\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Files and File Attachments\"\n---\n\nOJS provides you with a ton of flexibility and options for\ninteractivity on the browser side.  But what if you want to interact\nwith files in the file system? This is very common when you have some\nR or Python code that generates some data to be visualized.\nQuarto OJS provides `FileAttachment` objects, or simply \"file attachments\".\n\nFile attachments work similarly to how they do in Observable. You include them as\na resource in your quarto document or project, and then access them\nwith `FileAttachment`. Here we're using Allison Horst's excellent\n[palmer penguins dataset](penguins.csv)\n([source](https://allisonhorst.github.io/palmerpenguins/)):\n\n```{r}\n# This R code is run by Quarto, just like it would in (say) Rmarkdown.\nlibrary(palmerpenguins)\nwrite.csv(penguins, \"penguins.csv\")\n```\n\nWe now can reference this file directly in a file attachment:\n\n```{ojs}\ndata = FileAttachment(\"penguins.csv\").csv()\n```\n\nQuarto tries to figure out which files you want to use as attachments\nby inspecting OJS source code for `FileAttachment(...)` literals. If\nyou have arbitrary logic to decide on which filename to load, you will\nneed to explicitly add those files as resources in your project's\nYAML frontmatter (or in some of its pages).\n\n```{ojs}\navg = {\n  const vs = data.map(s => s.bill_length_mm).filter(s => s !== \"NA\").map(Number);\n  let n = 0;\n  vs.forEach(v => n += v);\n  return n / vs.length;\n}\n```\n\nThe average bill length of penguins in the dataset is ${fmt(avg)}mm.\n\n### Root-relative FileAttachments\n\nQuarto is careful to convert all local URL paths to \"root-relative\"\npaths, so that the entire Quarto project you build works, regardless\nof how deep in a web server path hierarchy you serve its content from.\nIn other words, if your markdown includes an image URL\n`/imgs/asset-1.jpg`, Quarto will convert that URL to a relative\none. In Quarto OJS, FileAttachments work the same way. For example,\nhere we check that `penguins.csv` and `/features/penguins.csv` indeed\nseem to be the same file:\n\n```{ojs}\ndata2 = FileAttachment(\"/features/penguins.csv\").csv()\n{\n    let randomRow = (now & 65535) % data.length;\n    return data2[randomRow].bill_length_mm === data[randomRow].bill_length_mm;\n}\n```\n\n### Extras\n\n```{ojs}\nfunction fmt(n)\n{\n   let s = String(~~n);\n   return s.substr(s.length - 2);\n}\n```\n\n\n\n\n{\"contents\":[\n  {\"methodName\":\"interpret\",\"inline\":\"true\",\"source\":\"htl.html`<span>${fmt(avg)}</span>`\", \"cellName\":\"ojs-element-id-1\"}\n]}"
  },
  {
    "href": "features/observable-modules.html",
    "title": "OJS Modules",
    "section": "",
    "text": "If you want to use the many existing observable modules that are present in the ecosystem, you can do so in the same way as you would in ObservableHQ. This way, Quarto users can contribute to the ObservableHQ ecosystem and vice-versa.\nThis example comes from Sean Lopp’s excellent “Observable for R Users” notebook.\nYou can use their require syntax:\n\nvg = require('vega-lite');\npenguins = FileAttachment(\"penguins.csv\").csv();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvl\n  .markPoint()                           // the first two lines are akin to ggplot(data = penguins) + geom_point\n  .data(penguins)\n  .encode(                               // encode is like aes\n    vl.x().fieldQ('body_mass_g')         // aes(x = body_mass_g)\n          .scale({domain: [2000, 6500]}) // modify scale attributes, similar to scale_x_axis\n          .axis({title: \"Mass (g)\"}),\n    vl.y().fieldQ('bill_length_mm')     \n          .scale({domain: [30, 60]}),\n    vl.color().fieldN('species'),\n    vl.tooltip(['species', 'sex', 'year', 'island'])  // tooltips for free!\n).render()\n\n\n\n\n\n\nYou can also import directly from a live ObservableHQ notebook. Let’s try a simple example using sliders:\n\nimport {slider} from \"@jashkenas/inputs\"\n\n\n\n\n\n\nHere, we’re also using Quarto’s custom layouts, which help when building dashboards.\n\nviewof hue = slider({min: 0, max: 360, title: \"Hue\"})\nviewof chroma = slider({min: 0, max: 100, title: \"Chroma\"})\nviewof luminance = slider({min: 0, max: 100, title: \"Luminance\"})\ncolor = {\n  const fill = d3.hcl(hue, chroma, luminance);\n  const r = htl.svg`<rect width=\"${width}\" height=\"30\" fill=\"${fill}\"/>`;\n  const s = DOM.svg(width, 30);\n  s.appendChild(r);\n  return s;\n}\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"OJS Modules\"\n---\n\nIf you want to use the many existing observable modules\nthat are present in the ecosystem, you can do so in the same way\nas you would in ObservableHQ. This way, Quarto users can contribute\nto the ObservableHQ ecosystem and vice-versa.\n\nThis example comes from Sean Lopp's excellent [\"Observable for R\nUsers\" notebook](https://observablehq.com/@slopp/observable-for-r-users).\n\nYou can use their `require` syntax:\n\n```{ojs}\n//| output: false\nvg = require('vega-lite');\npenguins = FileAttachment(\"penguins.csv\").csv();\n```\n\n```{ojs}\nvl\n  .markPoint()                           // the first two lines are akin to ggplot(data = penguins) + geom_point\n  .data(penguins)\n  .encode(                               // encode is like aes\n    vl.x().fieldQ('body_mass_g')         // aes(x = body_mass_g)\n          .scale({domain: [2000, 6500]}) // modify scale attributes, similar to scale_x_axis\n          .axis({title: \"Mass (g)\"}),\n    vl.y().fieldQ('bill_length_mm')     \n          .scale({domain: [30, 60]}),\n    vl.color().fieldN('species'),\n    vl.tooltip(['species', 'sex', 'year', 'island'])  // tooltips for free!\n).render()\n```\n\nYou can also import directly from a live ObservableHQ notebook. Let's\ntry a simple example using sliders:\n\n```{ojs}\n//| output: false\nimport {slider} from \"@jashkenas/inputs\"\n```\n\nHere, we're also using [Quarto's custom layouts](https://quarto.org/docs/authoring/figures-and-layout.html#complex-layouts),\nwhich help when building dashboards.\n\n```{ojs}\n//| layout: \"[[30, -5, 30, -5, 30], [100]]\"\nviewof hue = slider({min: 0, max: 360, title: \"Hue\"})\nviewof chroma = slider({min: 0, max: 100, title: \"Chroma\"})\nviewof luminance = slider({min: 0, max: 100, title: \"Luminance\"})\ncolor = {\n  const fill = d3.hcl(hue, chroma, luminance);\n  const r = htl.svg`<rect width=\"${width}\" height=\"30\" fill=\"${fill}\"/>`;\n  const s = DOM.svg(width, 30);\n  s.appendChild(r);\n  return s;\n}\n```"
  },
  {
    "href": "features/reactive-values.html#enter-reactive-values",
    "title": "Reactive Values",
    "section": "Enter reactive values",
    "text": "OJS, on the other hand, lets you define “reactive” values: special values that can change, and notify downstream code about the change. So, we can write this instead:\n\n// \"now\" is a predefined reactive value that returns the current\n// value of Date.now()\nreactiveTime = {\n  const hours = (now / (3600 * 1000)) % 12;\n  const minutes = (now / (60 * 1000)) % 60;\n  const seconds = (now / 1000) % 60;\n  \n  return { hours, minutes, seconds };\n}\n\n\n\n\n\n\nNow the values automatically update themselves. In OJS, you can write code that uses these as if they were regular Javascript values. OJS notices you’re using reactive values, and turns your definition into a reactive value as well:\n\ntimeString = htl.html`<tt>${fmt(reactiveTime.hours)}:${fmt(reactiveTime.minutes)}:${fmt(reactiveTime.seconds)}</tt>`\n\n\n\n\n\n\nBut we wanted an analog clock. So let’s make an analog clock, using SVG.\n\nclock = {\n   const { hours, minutes, seconds } = reactiveTime;\n   const result = svg`<svg width=200 height=200></svg>`;\n   const hourAngle = toClockAngle(hours / 12);\n   const minuteAngle = toClockAngle(minutes / 60);\n   const secondAngle = toClockAngle(seconds / 60);\n   const main = svg`<g transform=\"translate(100, 100) scale(1, -1)\"></g>`;\n   \n   result.appendChild(main);\n   main.appendChild(svg`<circle r=95 fill=\"#eee\"></circle>`);\n   main.appendChild(clockHand(secondAngle, \"red\", 1));\n   main.appendChild(clockHand(minuteAngle, \"black\", 1));\n   main.appendChild(clockHand(hourAngle, \"black\", 3));\n   return result;\n}\n\n\n\n\n\nFigure 1: An SVG clock built with reactive values.1\n\n\n\nOJS makes sure your SVG definition is also reactive, since it also uses reactive values."
  },
  {
    "href": "features/reactive-values.html#extras",
    "title": "Reactive Values",
    "section": "Extras",
    "text": "function fmt(n)\n{\n   const s = (\"00\" + String(~~n));\n   return s.substr(s.length - 2);\n}\nfunction toClockAngle(v)\n{\n  // some math is needed here because unlike polar coordinates, \n  // clock hands run clockwise and start at the \"north pole\"\n  return -(-Math.PI / 2 + Math.PI * 2 * v) * (180 / Math.PI);\n}\nfunction clockHand(angle, color, width)\n{\n  return svg`<line transform=\"rotate(${angle})\" x1=0 y1=0 x2=90 y2=0 stroke=${color} stroke-width=${width}></line>`\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Reactive Values\"\n---\n\nThe fundamental difference between \"plain Javascript\" and Observable's\nversion of Javascript (here, \"OJS\") is its native support for\n_reactivity_.\n\nImagine you wanted to create a simple visual time display shaped like\nan analog clock (or, looking ahead, imagine a JS dashboard that\nperiodically updates itself). Whatever you end up showing ultimately will\ndepend on the current time. So you start writing functions which compute\nthe present time:\n\n```{ojs}\n//| output: false\ncurrentTime = function() {\n  return Date.now();\n}\ncurrentHours = function() {\n  return (Date.now() / (3600 * 1000)) % 12;\n}\ncurrentMinutes = function() {\n  return (Date.now() / (60 * 1000)) % 60;\n}\ncurrentSeconds = function() {\n  return (Date.now() / 1000) % 60;\n}\n```\n\nBut `Date.now()` is always changing, and so your plain Javascript code needs\ninfrastructure to update the display constantly, otherwise that value\nis only computed once per call:\n\n```{ojs}\nstaticTime = { \n  return { hours: currentHours(), minutes: currentMinutes(), seconds: currentSeconds() };\n}\nhtl.html`<tt>${fmt(currentHours())}:${fmt(currentMinutes())}:${fmt(currentSeconds())}</tt>`\n```\n\n\"This is fine,\" you say. After all, we have Javascript:\n\n```{ojs}\nttEl = {\n  return document.createElement(\"tt\");\n}\n```\n```{ojs}\n//| output: false\nfunction updateEl() {\n  ttEl.innerText = `${fmt(currentHours())}:${fmt(currentMinutes())}:${fmt(currentSeconds())}`;\n  window.requestAnimationFrame(updateEl);\n}\nupdateEl()\n```\n\nBut what if your data only updates once a minute? What if you _don't\nknow_ how often your data updates?  Eventually code like this becomes\na delicate dance of signals and event handlers.  Things can get\nquickly out of hand.\n\n## Enter reactive values\n\nOJS, on the other hand, lets you define \"reactive\" values: special values that can\nchange, _and notify downstream code about the change_. So, we can write this instead:\n\n```{ojs}\n// \"now\" is a predefined reactive value that returns the current\n// value of Date.now()\nreactiveTime = {\n  const hours = (now / (3600 * 1000)) % 12;\n  const minutes = (now / (60 * 1000)) % 60;\n  const seconds = (now / 1000) % 60;\n  \n  return { hours, minutes, seconds };\n}\n```\n\nNow the values automatically update themselves. In OJS, you can\nwrite code that uses these as if they were regular Javascript\nvalues. OJS notices you're using reactive values, and turns\nyour definition into a reactive value as well:\n\n```{ojs}\ntimeString = htl.html`<tt>${fmt(reactiveTime.hours)}:${fmt(reactiveTime.minutes)}:${fmt(reactiveTime.seconds)}</tt>`\n```\n\nBut we wanted an analog clock. So let's make an analog clock, using\nSVG.\n\n```{ojs}\n//| label: fig-1\n//| fig.cap: An SVG clock built with reactive values.[^1]\nclock = {\n   const { hours, minutes, seconds } = reactiveTime;\n   const result = svg`<svg width=200 height=200></svg>`;\n   const hourAngle = toClockAngle(hours / 12);\n   const minuteAngle = toClockAngle(minutes / 60);\n   const secondAngle = toClockAngle(seconds / 60);\n   const main = svg`<g transform=\"translate(100, 100) scale(1, -1)\"></g>`;\n   \n   result.appendChild(main);\n   main.appendChild(svg`<circle r=95 fill=\"#eee\"></circle>`);\n   main.appendChild(clockHand(secondAngle, \"red\", 1));\n   main.appendChild(clockHand(minuteAngle, \"black\", 1));\n   main.appendChild(clockHand(hourAngle, \"black\", 3));\n   return result;\n}\n```\n\nOJS makes sure your SVG definition is also reactive, since it\nalso uses reactive values.\n\n## Extras\n\n```{ojs}\n//| output: false\nfunction fmt(n)\n{\n   const s = (\"00\" + String(~~n));\n   return s.substr(s.length - 2);\n}\nfunction toClockAngle(v)\n{\n  // some math is needed here because unlike polar coordinates, \n  // clock hands run clockwise and start at the \"north pole\"\n  return -(-Math.PI / 2 + Math.PI * 2 * v) * (180 / Math.PI);\n}\nfunction clockHand(angle, color, width)\n{\n  return svg`<line transform=\"rotate(${angle})\" x1=0 y1=0 x2=90 y2=0 stroke=${color} stroke-width=${width}></line>`\n}\n```\n\n[^1]: Note that `now` doesn't take timezones into account, so you're likely to see your clock a few hours off."
  },
  {
    "href": "tests/svg-test-1.html",
    "title": "SVG test 1",
    "section": "",
    "text": "mySvg = {\n  debugger;\n  return svg``;\n}\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"SVG test 1\"\n---\n\n```{ojs}\nmySvg = {\n  debugger;\n  return svg``;\n}\n```"
  },
  {
    "href": "tests/test-ojs-viewof-1.html",
    "title": "Testing OHQ views",
    "section": "",
    "text": "viewof x = html`<input type=range min=0 max=1 step=any>`\n\n\n\n\n\n\nWhat happens here?\n\n\nviewof x1 = html`<input type=range min=0 max=1 step=any>`\nviewof x2 = html`<input type=range min=0 max=1 step=any>`\n~~((x1 + x2) * 100)\n\n\n\n\n\n\n(a) the first view\n\n\n\n\n\n\n\n\n\n(b) the second view\n\n\n\n\n\n\n\n\n\n(c) the third element\n\n\n\nFigure 1: Many viewofs\n\n\n\nSource Code\n---\ntitle: \"Testing OHQ views\"\n---\n\n```{ojs}\nviewof x = html`<input type=range min=0 max=1 step=any>`\n```\n\nWhat happens here?\n\n```{ojs}\n//| label: fig-2\n//| fig.cap: \"Many viewofs\"\n//| fig.subcap:\n//|   - \"the first view\"\n//|   - \"the second view\"\n//|   - \"the third element\"\nviewof x1 = html`<input type=range min=0 max=1 step=any>`\nviewof x2 = html`<input type=range min=0 max=1 step=any>`\n~~((x1 + x2) * 100)\n```"
  },
  {
    "href": "tests/test-ojs-grammar-node-types.html",
    "title": "Inspecting the OJS grammar",
    "section": "",
    "text": "1;\nvar1 = 3;\nviewof var2 = html`<input type=range min=0 max=1 step=any>`;\n({ foo: \"bar\" });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Inspecting the OJS grammar\"\n---\n\n```{ojs}\n1;\nvar1 = 3;\nviewof var2 = html`<input type=range min=0 max=1 step=any>`;\n({ foo: \"bar\" });\n```"
  },
  {
    "href": "tests/index.html#svg",
    "title": "Quarto Observable Test Index",
    "section": "SVG",
    "text": "svg-test-1."
  },
  {
    "href": "tests/index.html#ojs-display-tests",
    "title": "Quarto Observable Test Index",
    "section": "OJS display tests",
    "text": "OJS grammar node types\nOJS object inspector"
  },
  {
    "href": "tests/index.html#views",
    "title": "Quarto Observable Test Index",
    "section": "Views",
    "text": "test 1\n\n\nSource Code\n---\ntitle: \"Quarto Observable Test Index\"\n---\n\n## SVG\n\n* [svg-test-1](svg-test-1.qmd).\n\n## OJS display tests\n\n* [OJS grammar node types](test-ojs-grammar-node-types.qmd)\n* [OJS object inspector](test-ojs-object-inspector.qmd)\n\n## Views\n\n* [test 1](test-ojs-viewof-1.qmd)"
  },
  {
    "href": "tests/test-ojs-object-inspector.html",
    "title": "Test OJS Object Inspector",
    "section": "",
    "text": "v = ({\n  a: 1,\n  b: \"foo\",\n  c: null,\n  d: true,\n  e: undefined,\n  f: [1, 2, 3],\n  g: {\n    some: \"more\"\n  },\n  h: function(x) { return x + x; },\n  i: (y) => y * y\n})\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Test OJS Object Inspector\"\n---\n\n```{ojs}\nv = ({\n  a: 1,\n  b: \"foo\",\n  c: null,\n  d: true,\n  e: undefined,\n  f: [1, 2, 3],\n  g: {\n    some: \"more\"\n  },\n  h: function(x) { return x + x; },\n  i: (y) => y * y\n})\n```"
  },
  {
    "href": "index.html",
    "title": "Quarto OJS",
    "section": "",
    "text": "Quarto provides a number of format outputs, one of which is HTML. The HTML format uniquely supports interactivity: web browsers can show animations, respond to user input, and run user-defined code. Quarto leverages ObservableHQ’s runtime to support this kind of interactivity. At a glance, this enables document authors to write code in a variant of Javascript. We can use it to easily embed interactive visualizations in Quarto documents:\n\ngraphJson = FileAttachment(\"/data/karate-club.json\").json()\ngraph = {\n  const nodeSet = new Set();\n  const nodes = [];\n  graphJson.edges.forEach(edge => {\n    if (!nodeSet.has(edge.source)) {\n      nodeSet.add(edge.source);\n      nodes.push({id: edge.source});\n    }\n    if (!nodeSet.has(edge.target)) {\n      nodeSet.add(edge.target);\n      nodes.push({id: edge.target});\n    }\n  });\n  return {\n    nodes,\n    links: graphJson.edges\n  };\n}\nmyHeight = 400\nimport { chart } with { graph as data, myHeight as height } from \"@d3/force-directed-graph\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart\n\n\n\n\n\nFigure 1: Zachary’s Karate club network, visualized with d3’s force-directed layout\n\n\n\nFIXME: all of these are going to be links to examples in this project.\nQuarto-OJS is built to make it easy for document authors to create a range of documents, from interactive expository pieces to dashboards.\nYour documents can use Python or R for data processing, and then use a number of Javascript libraries (such as d3 or vega-lite) to present the final output. You can write your own custom Javascript, or you can directly import from existing reactive notebook, either in your Quarto project or from ObservableHQ. If you’re using R specifically, you can use Quarto to build and run Shiny servers, and Shiny interop is a breeze: Shiny reactives work directly as inputs to OJS cells (and OJS views work as Shiny inputs).\n\nSource Code\n---\ntitle: \"Quarto OJS\"\n---\n\nQuarto provides a number of format outputs, one of which is HTML. The\nHTML format uniquely supports **interactivity**: web browsers can show\nanimations, respond to user input, and run user-defined code.\nQuarto leverages [ObservableHQ](https://observablehq.com)'s runtime \nto support this kind of interactivity.\nAt a glance, this enables document authors to write code in a variant\nof Javascript. We can use it to easily embed interactive visualizations in\nQuarto documents:\n\n```{ojs}\n//| echo: false\n//| output: false\ngraphJson = FileAttachment(\"/data/karate-club.json\").json()\ngraph = {\n  const nodeSet = new Set();\n  const nodes = [];\n  graphJson.edges.forEach(edge => {\n    if (!nodeSet.has(edge.source)) {\n      nodeSet.add(edge.source);\n      nodes.push({id: edge.source});\n    }\n    if (!nodeSet.has(edge.target)) {\n      nodeSet.add(edge.target);\n      nodes.push({id: edge.target});\n    }\n  });\n  return {\n    nodes,\n    links: graphJson.edges\n  };\n}\nmyHeight = 400\nimport { chart } with { graph as data, myHeight as height } from \"@d3/force-directed-graph\";\n```\n\n```{ojs}\n//| echo: false\n//| label: fig-karate-club\n//| fig.cap: <a href=\"https://en.wikipedia.org/wiki/Zachary%27s_karate_club\">Zachary's Karate club network</a>, visualized with d3's force-directed layout\nchart\n```\n\n**FIXME: all of these are going to be links to examples in this project**.\n\nQuarto-OJS is built to make it easy for document authors to create a\nrange of documents, from interactive expository pieces to dashboards.\n\nYour documents can use Python or R for data processing, and then use a\nnumber of Javascript libraries (such as d3 or vega-lite) to present\nthe final output. You can write your own custom Javascript, or you can\ndirectly import from existing reactive notebook, either in your Quarto\nproject or from ObservableHQ. If you're using R specifically, you can\nuse Quarto to build and run Shiny servers, and Shiny interop is a\nbreeze: Shiny reactives work directly as inputs to OJS cells (and OJS\nviews work as Shiny inputs)."
  },
  {
    "href": "module-tests/default-module-import.html",
    "title": "Default Module Import test",
    "section": "",
    "text": "Let’s observe ojs imports.\n\nimport { slider } from \"@jashkenas/inputs\"\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Default Module Import test\"\n---\n\nLet's observe ojs imports.\n\n```{ojs}\nimport { slider } from \"@jashkenas/inputs\"\n```"
  },
  {
    "href": "module-tests/module-import-2.html",
    "title": "ES6 Recursive Imports",
    "section": "",
    "text": "We also support ES6 recursive imports, and Quarto traverses the ES6 modules recursively to include them as resources in your project.\n\n// test-2.js itself imports a bar.js ES6 module.\nimport { v1, v2 } from \"./test-2.js\";\n\n\n\n\n\n\n\nv1()\nv2()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"ES6 Recursive Imports\"\n---\n\nWe also support ES6 recursive imports, and Quarto traverses the ES6 modules\nrecursively to include them as resources in your project.\n\n```{ojs}\n// test-2.js itself imports a bar.js ES6 module.\nimport { v1, v2 } from \"./test-2.js\";\n```\n\n```{ojs}\nv1()\nv2()\n```"
  },
  {
    "href": "module-tests/es6-module-import.html",
    "title": "ES6 Module Imports",
    "section": "",
    "text": "In addition to regular imports from observablehq notebooks, Quarto OJS also supports ES6 module imports from local files. In this basic case, we have a very simple test file:\n\nimport { test } from \"./test.js\";\ntest()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuarto notices the ./test.js being imported and automatically includes it as a resource to be added to the project build.\n\nSource Code\n---\ntitle: \"ES6 Module Imports\"\n---\n\nIn addition to regular imports from observablehq notebooks, Quarto OJS also\nsupports ES6 module imports from local files. In this basic case, we\nhave a [very simple test file](test.js):\n\n```{ojs}\nimport { test } from \"./test.js\";\ntest()\n```\n\nQuarto notices the `./test.js` being imported and automatically\nincludes it as a resource to be added to the project build."
  },
  {
    "href": "module-tests/ojs-module.html",
    "title": "OJS module",
    "section": "",
    "text": "An import from a simple module:\n\nimport { nowInSecs } from './test.ojs'\nnowInSecs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn import from a slightly more complicated module:\n\nimport { out } from './test-2.ojs'\nout\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, we can import modules from other Quarto-OJS notebooks. In this case, we simply import the SVG clock we created in the reactive values intro:\n\nimport { clock } from '../features/reactive-values.qmd';\nclock\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"OJS module\"\n---\n\nAn import from a simple module:\n\n```{ojs}\nimport { nowInSecs } from './test.ojs'\nnowInSecs\n```\n\nAn import from a slightly more complicated module:\n\n```{ojs}\nimport { out } from './test-2.ojs'\nout\n```\n\nFinally, we can import modules from other Quarto-OJS notebooks. In\nthis case, we simply import the SVG clock we created [in the reactive values intro](../features/reactive-values.qmd):\n\n```{ojs}\nimport { clock } from '../features/reactive-values.qmd';\nclock\n```"
  },
  {
    "href": "module-tests/module-import.html",
    "title": "Module Import test",
    "section": "",
    "text": "We’ll have to override the import statements here to do something special.\n\nimport { test } from \"./test.js\";\n\n\n\n\n\n\n\ntest()\n\n\n\n\n\n\n\nSource Code\n---\ntitle: \"Module Import test\"\n---\n\nWe'll have to override the import statements here to do something special.\n\n```{ojs}\nimport { test } from \"./test.js\";\n```\n\n```{ojs}\ntest()\n```"
  }
]
---
title: "Reactive Values"
---

The fundamental difference between "plain Javascript" and Observable's
version of Javascript (here, "OJS") is its native support for
_reactivity_.

Imagine you wanted to create a simple visual time display shaped like
an analog clock (or, looking ahead, imagine a JS dashboard that
periodically updates itself). Whatever you end up showing ultimately will
depend on the current time. 

```{ojs}
//| output: false
currentTime = function() {
  return Date.now();
}
currentHours = function() {
  return (Date.now() / (3600 * 1000)) % 12
}
currentMinutes = function() {
  return (Date.now() / (60 * 1000)) % 60;
}
currentSeconds = function() {
  return (Date.now() / 1000) % 60;
}
```

But "now" is always changing, and so your plain Javascript code needs
to have infrastructure to update the display constantly, otherwise
that value is only computed once per call:

```{ojs}
currentHours()
currentMinutes()
currentSeconds()
```

Eventually will have to do something like set up a periodic call to
update your code every time you want to redraw, as well as manage
state dependencies manually, and so on. Things can get quickly out of
hand.

## Enter reactive values

OJS lets you define "reactive" values: special values that can
change, _and notify downstream code about the change_. So, we can write this instead:

```{ojs}
// "now" is a predefined reactive value that returns the current
// value of Date.now()
hours = (now / (3600 * 1000)) % 12
minutes = (now / (60 * 1000)) % 60
seconds = (now / 1000) % 60
```

Now the values automatically update themselves. In OJS, you can
write code that uses these as if they were regular Javascript
values. OJS notices you're using reactive values, and turns
your definition into a reactive value as well:

```{ojs}
timeString = `${fmt(hours)}:${fmt(minutes)}:${fmt(seconds)}`
```

But we wanted an analog clock. So let's make an analog clock, using
SVG.

```{ojs}
//| label: fig-1
//| fig.cap: An SVG clock built with reactive values.[^1]
clock = {
   let result = svg`<svg width=200 height=200></svg>`;
   let hourAngle = toClockAngle(hours / 12);
   let minuteAngle = toClockAngle(minutes / 60);
   let secondAngle = toClockAngle(seconds / 60);
   let main = svg`<g transform="translate(100, 100) scale(1, -1)"></g>`;
   result.appendChild(main);
   main.appendChild(svg`<circle r=95 fill="#eee"></circle>`);
   main.appendChild(clockHand(secondAngle, "red", 1));
   main.appendChild(clockHand(minuteAngle, "black", 1));
   main.appendChild(clockHand(hourAngle, "black", 3));
   return result;
}
```

OJS makes sure your SVG definition is also reactive, since it
also uses reactive values.

## Extras

```{ojs}
//| output: false
function fmt(n)
{
   let s = ("00" + String(~~n))
   return s.substr(s.length - 2);
}
function toClockAngle(v)
{
  // some math is needed here because unlike polar coordinates, 
  // clock hands run clockwise and start at the "north pole"
  return -(-Math.PI / 2 + Math.PI * 2 * v) * (180 / Math.PI);
}
function clockHand(angle, color, width)
{
  return svg`<line transform="rotate(${angle})" x1=0 y1=0 x2=90 y2=0 stroke=${color} stroke-width=${width}></line>`
}
```

[^1]: Note that `now` doesn't take timezones into account, so you're likely to see your clock a few hours off.
